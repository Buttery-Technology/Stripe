//
//  ThinEvent.swift
//  Stripe
//
//  V2 API - Thin events for lightweight event notifications.
//

import Foundation

/// A thin event is a lightweight event notification from the v2 API.
///
/// Unlike v1 snapshot events which include the full object data, thin events only
/// include the ID of the affected objects. You should make a subsequent API call
/// to fetch the complete Event object or the related resource's latest state.
///
/// Thin events are generated by API v2 endpoints and some v1 endpoints.
///
/// - Note: Because thin events don't include object snapshots, you should always
///   fetch the latest version of the resource from the API when processing events.
public struct ThinEvent: Codable {
    /// Unique identifier for the event.
    public let id: String

    /// String representing the object's type. Always "event" for events.
    public let object: String

    /// The Stripe API version used to render the event data.
    public let apiVersion: String?

    /// Time at which the event was created. Measured in seconds since the Unix epoch.
    public let created: TimeInterval

    /// Has the value `true` if the object exists in live mode or `false` if in test mode.
    public let livemode: Bool

    /// Description of the event (e.g., `invoice.payment_succeeded`).
    public let type: String

    /// Object containing the reference to the API resource relevant to the event.
    public let relatedObject: RelatedObject

    /// The reason for the event.
    public let reason: EventReason?

    /// Designated initializer
    public init(id: String, object: String, apiVersion: String?, created: TimeInterval, livemode: Bool, type: String, relatedObject: RelatedObject, reason: EventReason?) {
        self.id = id
        self.object = object
        self.apiVersion = apiVersion
        self.created = created
        self.livemode = livemode
        self.type = type
        self.relatedObject = relatedObject
        self.reason = reason
    }

    public enum CodingKeys: String, CodingKey {
        case id,
             object,
             apiVersion = "api_version",
             created,
             livemode,
             type,
             relatedObject = "related_object",
             reason
    }

    // MARK: - Related Object

    /// A reference to the object that triggered the event.
    public struct RelatedObject: Codable {
        /// Unique identifier for the object.
        public let id: String

        /// Type of the object (e.g., "charge", "customer", "invoice").
        public let type: String

        /// URL to retrieve the object.
        public let url: String?

        public init(id: String, type: String, url: String?) {
            self.id = id
            self.type = type
            self.url = url
        }
    }

    // MARK: - Event Reason

    /// The reason for the event.
    public struct EventReason: Codable {
        /// The type of reason.
        public let type: ReasonType

        /// The request that triggered the event, if applicable.
        public let request: RequestInfo?

        public init(type: ReasonType, request: RequestInfo?) {
            self.type = type
            self.request = request
        }

        /// The type of reason that triggered the event.
        public enum ReasonType: String, Codable {
            /// The event was triggered by an API request.
            case request

            /// The event was triggered automatically by Stripe.
            case automatic
        }

        /// Information about the request that triggered the event.
        public struct RequestInfo: Codable {
            /// The ID of the request that triggered the event.
            public let id: String

            /// The idempotency key used for the request, if any.
            public let idempotencyKey: String?

            public init(id: String, idempotencyKey: String?) {
                self.id = id
                self.idempotencyKey = idempotencyKey
            }

            public enum CodingKeys: String, CodingKey {
                case id,
                     idempotencyKey = "idempotency_key"
            }
        }
    }
}

// MARK: - V2 Event (Full)

/// A full v2 event object that can be retrieved after receiving a thin event.
public struct V2Event: Codable {
    /// Unique identifier for the event.
    public let id: String

    /// String representing the object's type.
    public let object: String

    /// The Stripe API version used to render the event data.
    public let apiVersion: String?

    /// Time at which the event was created. Measured in seconds since the Unix epoch.
    public let created: TimeInterval

    /// Has the value `true` if the object exists in live mode or `false` if in test mode.
    public let livemode: Bool

    /// Description of the event (e.g., `v2.core.event_destination.created`).
    public let type: String

    /// Object containing data associated with the event.
    public let data: EventData?

    /// The reason for the event.
    public let reason: ThinEvent.EventReason?

    /// Object containing the reference to the API resource relevant to the event.
    public let relatedObject: ThinEvent.RelatedObject?

    /// Designated initializer
    public init(id: String, object: String, apiVersion: String?, created: TimeInterval, livemode: Bool, type: String, data: EventData?, reason: ThinEvent.EventReason?, relatedObject: ThinEvent.RelatedObject?) {
        self.id = id
        self.object = object
        self.apiVersion = apiVersion
        self.created = created
        self.livemode = livemode
        self.type = type
        self.data = data
        self.reason = reason
        self.relatedObject = relatedObject
    }

    public enum CodingKeys: String, CodingKey {
        case id,
             object,
             apiVersion = "api_version",
             created,
             livemode,
             type,
             data,
             reason,
             relatedObject = "related_object"
    }

    // MARK: - Event Data

    /// The data payload of the event.
    public struct EventData: Codable {
        /// The data object. The structure depends on the event type.
        /// Use a custom decoder to parse specific event types.
        public let object: [String: AnyCodable]?

        public init(object: [String: AnyCodable]?) {
            self.object = object
        }
    }
}

// MARK: - JSONNull (Cross-platform null representation)

/// A cross-platform representation of JSON null.
/// Used instead of NSNull for Linux compatibility.
public struct JSONNull: Equatable, Hashable {
    public init() {}
}

// MARK: - AnyCodable Helper

/// A type-erased Codable value for handling dynamic JSON structures.
public struct AnyCodable: Codable {
    public let value: Any

    public init(_ value: Any) {
        self.value = value
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()

        if container.decodeNil() {
            self.value = JSONNull()
        } else if let bool = try? container.decode(Bool.self) {
            self.value = bool
        } else if let int = try? container.decode(Int.self) {
            self.value = int
        } else if let double = try? container.decode(Double.self) {
            self.value = double
        } else if let string = try? container.decode(String.self) {
            self.value = string
        } else if let array = try? container.decode([AnyCodable].self) {
            self.value = array.map { $0.value }
        } else if let dictionary = try? container.decode([String: AnyCodable].self) {
            self.value = dictionary.mapValues { $0.value }
        } else {
            throw Swift.DecodingError.dataCorrupted(Swift.DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Unable to decode value"))
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()

        switch value {
        case is JSONNull:
            try container.encodeNil()
        case let bool as Bool:
            try container.encode(bool)
        case let int as Int:
            try container.encode(int)
        case let double as Double:
            try container.encode(double)
        case let string as String:
            try container.encode(string)
        case let array as [Any]:
            try container.encode(array.map { AnyCodable($0) })
        case let dictionary as [String: Any]:
            try container.encode(dictionary.mapValues { AnyCodable($0) })
        default:
            throw Swift.EncodingError.invalidValue(value, Swift.EncodingError.Context(codingPath: container.codingPath, debugDescription: "Unable to encode value"))
        }
    }
}
