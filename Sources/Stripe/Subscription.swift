//
//  Subscription.swift
//  Stripe
//
//  Full Subscription object for the Stripe API.
//

import Foundation

public struct Subscription: Codable {
    public static let schema = "subscriptions"

    /// Unique identifier for the object.
    public let id: String
    /// String representing the object's type.
    public let object: String
    /// ID of the Connect Application that created the subscription.
    public let application: String?
    /// A non-negative decimal between 0 and 100, with at most two decimal places.
    public let applicationFeePercent: Double?
    /// Configuration for automatic tax collection.
    public let automaticTax: AutomaticTax
    /// The reference point that aligns future billing cycle dates.
    public let billingCycleAnchor: TimeInterval
    /// Configuration for the billing cycle anchor.
    public let billingCycleAnchorConfig: BillingCycleAnchorConfig?
    /// Describes the billing mode for the subscription.
    public let billingMode: BillingMode?
    /// Define thresholds at which an invoice will be sent.
    public let billingThresholds: BillingThresholds?
    /// A date in the future at which the subscription will automatically get canceled.
    public let cancelAt: TimeInterval?
    /// If the subscription has been canceled with the `at_period_end` flag.
    public let cancelAtPeriodEnd: Bool
    /// If the subscription has been canceled, the date of that cancellation.
    public let canceledAt: TimeInterval?
    /// Details about why this subscription was cancelled.
    public let cancellationDetails: CancellationDetails?
    /// Either `charge_automatically` or `send_invoice`.
    public let collectionMethod: CollectionMethod
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public let created: TimeInterval
    /// Three-letter ISO currency code.
    public let currency: String
    /// End of the current period that the subscription has been invoiced for.
    public let currentPeriodEnd: TimeInterval
    /// Start of the current period that the subscription has been invoiced for.
    public let currentPeriodStart: TimeInterval
    /// ID of the customer who owns the subscription.
    public let customer: String
    /// ID of the CustomerAccount who owns the subscription, if one exists.
    public let customerAccount: String?
    /// Number of days a customer has to pay invoices generated by this subscription.
    public let daysUntilDue: Int?
    /// ID of the default payment method for the subscription.
    public let defaultPaymentMethod: String?
    /// ID of the default payment source for the subscription.
    public let defaultSource: String?
    /// The tax rates that will apply to any subscription item that does not have tax_rates set.
    public let defaultTaxRates: [TaxRate]?
    /// The subscription's description.
    public let subscriptionDescription: String?
    /// The discounts applied to the subscription.
    public let discounts: [String]
    /// If the subscription has ended, the date the subscription ended.
    public let endedAt: TimeInterval?
    /// The subscription's invoice settings.
    public let invoiceSettings: SubscriptionInvoiceSettings
    /// List of subscription items, each with an attached price.
    public let items: ListObject<SubscriptionItem>
    /// The most recent invoice this subscription has generated.
    public let latestInvoice: String?
    /// Has the value `true` if the object exists in live mode.
    public let livemode: Bool
    /// Set of key-value pairs attached to the object.
    public let metadata: Metadata
    /// Specifies the approximate timestamp on which any pending invoice items will be billed.
    public let nextPendingInvoiceItemInvoice: TimeInterval?
    /// The account on behalf of which to charge.
    public let onBehalfOf: String?
    /// If specified, payment collection for this subscription will be paused.
    public let pauseCollection: PauseCollection?
    /// Payment settings passed on to invoices created by the subscription.
    public let paymentSettings: SubscriptionPaymentSettings?
    /// Specifies an interval for how often to bill for any pending invoice items.
    public let pendingInvoiceItemInterval: PendingInvoiceItemInterval?
    /// You can use this SetupIntent to collect user authentication.
    public let pendingSetupIntent: String?
    /// If specified, pending updates that will be applied to the subscription once the latest_invoice has been paid.
    public let pendingUpdate: PendingUpdate?
    /// The schedule attached to the subscription.
    public let schedule: String?
    /// Date when the subscription was first created.
    public let startDate: TimeInterval
    /// Possible values are `incomplete`, `incomplete_expired`, `trialing`, `active`, `past_due`, `canceled`, `unpaid`, or `paused`.
    public let status: Status
    /// ID of the test clock this subscription belongs to.
    public let testClock: String?
    /// The account (if any) the subscription's payments will be attributed to for tax reporting.
    public let transferData: TransferData?
    /// If the subscription has a trial, the end of that trial.
    public let trialEnd: TimeInterval?
    /// Settings related to subscription trials.
    public let trialSettings: TrialSettings?
    /// If the subscription has a trial, the beginning of that trial.
    public let trialStart: TimeInterval?

    public init(id: String, object: String, application: String?, applicationFeePercent: Double?, automaticTax: AutomaticTax, billingCycleAnchor: TimeInterval, billingCycleAnchorConfig: BillingCycleAnchorConfig?, billingMode: BillingMode?, billingThresholds: BillingThresholds?, cancelAt: TimeInterval?, cancelAtPeriodEnd: Bool, canceledAt: TimeInterval?, cancellationDetails: CancellationDetails?, collectionMethod: CollectionMethod, created: TimeInterval, currency: String, currentPeriodEnd: TimeInterval, currentPeriodStart: TimeInterval, customer: String, customerAccount: String?, daysUntilDue: Int?, defaultPaymentMethod: String?, defaultSource: String?, defaultTaxRates: [TaxRate]?, subscriptionDescription: String?, discounts: [String], endedAt: TimeInterval?, invoiceSettings: SubscriptionInvoiceSettings, items: ListObject<SubscriptionItem>, latestInvoice: String?, livemode: Bool, metadata: Metadata, nextPendingInvoiceItemInvoice: TimeInterval?, onBehalfOf: String?, pauseCollection: PauseCollection?, paymentSettings: SubscriptionPaymentSettings?, pendingInvoiceItemInterval: PendingInvoiceItemInterval?, pendingSetupIntent: String?, pendingUpdate: PendingUpdate?, schedule: String?, startDate: TimeInterval, status: Status, testClock: String?, transferData: TransferData?, trialEnd: TimeInterval?, trialSettings: TrialSettings?, trialStart: TimeInterval?) {
        self.id = id
        self.object = object
        self.application = application
        self.applicationFeePercent = applicationFeePercent
        self.automaticTax = automaticTax
        self.billingCycleAnchor = billingCycleAnchor
        self.billingCycleAnchorConfig = billingCycleAnchorConfig
        self.billingMode = billingMode
        self.billingThresholds = billingThresholds
        self.cancelAt = cancelAt
        self.cancelAtPeriodEnd = cancelAtPeriodEnd
        self.canceledAt = canceledAt
        self.cancellationDetails = cancellationDetails
        self.collectionMethod = collectionMethod
        self.created = created
        self.currency = currency
        self.currentPeriodEnd = currentPeriodEnd
        self.currentPeriodStart = currentPeriodStart
        self.customer = customer
        self.customerAccount = customerAccount
        self.daysUntilDue = daysUntilDue
        self.defaultPaymentMethod = defaultPaymentMethod
        self.defaultSource = defaultSource
        self.defaultTaxRates = defaultTaxRates
        self.subscriptionDescription = subscriptionDescription
        self.discounts = discounts
        self.endedAt = endedAt
        self.invoiceSettings = invoiceSettings
        self.items = items
        self.latestInvoice = latestInvoice
        self.livemode = livemode
        self.metadata = metadata
        self.nextPendingInvoiceItemInvoice = nextPendingInvoiceItemInvoice
        self.onBehalfOf = onBehalfOf
        self.pauseCollection = pauseCollection
        self.paymentSettings = paymentSettings
        self.pendingInvoiceItemInterval = pendingInvoiceItemInterval
        self.pendingSetupIntent = pendingSetupIntent
        self.pendingUpdate = pendingUpdate
        self.schedule = schedule
        self.startDate = startDate
        self.status = status
        self.testClock = testClock
        self.transferData = transferData
        self.trialEnd = trialEnd
        self.trialSettings = trialSettings
        self.trialStart = trialStart
    }

    public enum CodingKeys: String, CodingKey {
        case id,
             object,
             application,
             applicationFeePercent = "application_fee_percent",
             automaticTax = "automatic_tax",
             billingCycleAnchor = "billing_cycle_anchor",
             billingCycleAnchorConfig = "billing_cycle_anchor_config",
             billingMode = "billing_mode",
             billingThresholds = "billing_thresholds",
             cancelAt = "cancel_at",
             cancelAtPeriodEnd = "cancel_at_period_end",
             canceledAt = "canceled_at",
             cancellationDetails = "cancellation_details",
             collectionMethod = "collection_method",
             created,
             currency,
             currentPeriodEnd = "current_period_end",
             currentPeriodStart = "current_period_start",
             customer,
             customerAccount = "customer_account",
             daysUntilDue = "days_until_due",
             defaultPaymentMethod = "default_payment_method",
             defaultSource = "default_source",
             defaultTaxRates = "default_tax_rates",
             subscriptionDescription = "description",
             discounts,
             endedAt = "ended_at",
             invoiceSettings = "invoice_settings",
             items,
             latestInvoice = "latest_invoice",
             livemode,
             metadata,
             nextPendingInvoiceItemInvoice = "next_pending_invoice_item_invoice",
             onBehalfOf = "on_behalf_of",
             pauseCollection = "pause_collection",
             paymentSettings = "payment_settings",
             pendingInvoiceItemInterval = "pending_invoice_item_interval",
             pendingSetupIntent = "pending_setup_intent",
             pendingUpdate = "pending_update",
             schedule,
             startDate = "start_date",
             status,
             testClock = "test_clock",
             transferData = "transfer_data",
             trialEnd = "trial_end",
             trialSettings = "trial_settings",
             trialStart = "trial_start"
    }

    // MARK: - Status

    public enum Status: String, Codable {
        case active
        case canceled
        case incomplete
        case incompleteExpired = "incomplete_expired"
        case pastDue = "past_due"
        case paused
        case trialing
        case unpaid
    }

    // MARK: - Collection Method

    public enum CollectionMethod: String, Codable {
        case chargeAutomatically = "charge_automatically"
        case sendInvoice = "send_invoice"
    }

    // MARK: - Automatic Tax

    public struct AutomaticTax: Codable {
        /// Whether automatic tax collection is enabled.
        public let enabled: Bool
        /// The reason automatic tax is disabled, if applicable.
        public let disabledReason: String?
        /// The account that's liable for tax.
        public let liability: Liability?

        public init(enabled: Bool, disabledReason: String?, liability: Liability?) {
            self.enabled = enabled
            self.disabledReason = disabledReason
            self.liability = liability
        }

        public enum CodingKeys: String, CodingKey {
            case enabled,
                 disabledReason = "disabled_reason",
                 liability
        }

        public struct Liability: Codable {
            /// The connected account being referenced.
            public let account: String?
            /// Type of the account referenced.
            public let type: LiabilityType

            public init(account: String?, type: LiabilityType) {
                self.account = account
                self.type = type
            }

            public enum LiabilityType: String, Codable {
                case account
                case `self`
            }
        }
    }

    // MARK: - Billing Cycle Anchor Config

    public struct BillingCycleAnchorConfig: Codable {
        /// The day of the month the billing_cycle_anchor should be.
        public let dayOfMonth: Int
        /// The hour of the day the billing_cycle_anchor should be.
        public let hour: Int?
        /// The minute of the hour the billing_cycle_anchor should be.
        public let minute: Int?
        /// The month to start full billing periods.
        public let month: Int?
        /// The second of the minute the billing_cycle_anchor should be.
        public let second: Int?

        public init(dayOfMonth: Int, hour: Int?, minute: Int?, month: Int?, second: Int?) {
            self.dayOfMonth = dayOfMonth
            self.hour = hour
            self.minute = minute
            self.month = month
            self.second = second
        }

        public enum CodingKeys: String, CodingKey {
            case dayOfMonth = "day_of_month",
                 hour,
                 minute,
                 month,
                 second
        }
    }

    // MARK: - Billing Mode

    public struct BillingMode: Codable {
        /// The type of billing mode.
        public let type: BillingModeType

        public init(type: BillingModeType) {
            self.type = type
        }

        public enum BillingModeType: String, Codable {
            case classic
            case flexible
        }
    }

    // MARK: - Billing Thresholds

    public struct BillingThresholds: Codable {
        /// Monetary threshold that triggers the subscription to advance to a new billing period.
        public let amountGte: Int?
        /// Indicates if the billing_cycle_anchor should be reset when a threshold is reached.
        public let resetBillingCycleAnchor: Bool?

        public init(amountGte: Int?, resetBillingCycleAnchor: Bool?) {
            self.amountGte = amountGte
            self.resetBillingCycleAnchor = resetBillingCycleAnchor
        }

        public enum CodingKeys: String, CodingKey {
            case amountGte = "amount_gte",
                 resetBillingCycleAnchor = "reset_billing_cycle_anchor"
        }
    }

    // MARK: - Cancellation Details

    public struct CancellationDetails: Codable {
        /// Additional comments about why the user canceled the subscription.
        public let comment: String?
        /// The customer submitted reason for why they canceled.
        public let feedback: CancellationFeedback?
        /// Why this subscription was canceled.
        public let reason: CancellationReason?

        public init(comment: String?, feedback: CancellationFeedback?, reason: CancellationReason?) {
            self.comment = comment
            self.feedback = feedback
            self.reason = reason
        }

        public enum CancellationFeedback: String, Codable {
            case customerService = "customer_service"
            case lowQuality = "low_quality"
            case missingFeatures = "missing_features"
            case other
            case switchedService = "switched_service"
            case tooComplex = "too_complex"
            case tooExpensive = "too_expensive"
            case unused
        }

        public enum CancellationReason: String, Codable {
            case cancellationRequested = "cancellation_requested"
            case paymentDisputed = "payment_disputed"
            case paymentFailed = "payment_failed"
        }
    }

    // MARK: - Subscription Invoice Settings

    public struct SubscriptionInvoiceSettings: Codable {
        /// The account tax IDs associated with the subscription.
        public let accountTaxIds: [String]?
        /// The connected account that issues the invoice.
        public let issuer: Issuer

        public init(accountTaxIds: [String]?, issuer: Issuer) {
            self.accountTaxIds = accountTaxIds
            self.issuer = issuer
        }

        public enum CodingKeys: String, CodingKey {
            case accountTaxIds = "account_tax_ids",
                 issuer
        }
    }

    // MARK: - Issuer

    public struct Issuer: Codable {
        /// The connected account being referenced.
        public let account: String?
        /// Type of the account referenced.
        public let type: IssuerType

        public init(account: String?, type: IssuerType) {
            self.account = account
            self.type = type
        }

        public enum IssuerType: String, Codable {
            case account
            case `self`
        }
    }

    // MARK: - Pause Collection

    public struct PauseCollection: Codable {
        /// The payment collection behavior for this subscription.
        public let behavior: PauseBehavior
        /// The time after which the subscription will resume collecting payments.
        public let resumesAt: TimeInterval?

        public init(behavior: PauseBehavior, resumesAt: TimeInterval?) {
            self.behavior = behavior
            self.resumesAt = resumesAt
        }

        public enum CodingKeys: String, CodingKey {
            case behavior,
                 resumesAt = "resumes_at"
        }

        public enum PauseBehavior: String, Codable {
            case keepAsDraft = "keep_as_draft"
            case markUncollectible = "mark_uncollectible"
            case void
        }
    }

    // MARK: - Subscription Payment Settings

    public struct SubscriptionPaymentSettings: Codable {
        /// Payment-method-specific configuration to provide to invoices.
        public let paymentMethodOptions: [String: AnyCodable]?
        /// The list of payment method types to provide to every invoice.
        public let paymentMethodTypes: [String]?
        /// Configure whether Stripe updates `subscription.default_payment_method`.
        public let saveDefaultPaymentMethod: SaveDefaultPaymentMethod?

        public init(paymentMethodOptions: [String: AnyCodable]?, paymentMethodTypes: [String]?, saveDefaultPaymentMethod: SaveDefaultPaymentMethod?) {
            self.paymentMethodOptions = paymentMethodOptions
            self.paymentMethodTypes = paymentMethodTypes
            self.saveDefaultPaymentMethod = saveDefaultPaymentMethod
        }

        public enum CodingKeys: String, CodingKey {
            case paymentMethodOptions = "payment_method_options",
                 paymentMethodTypes = "payment_method_types",
                 saveDefaultPaymentMethod = "save_default_payment_method"
        }

        public enum SaveDefaultPaymentMethod: String, Codable {
            case off
            case onSubscription = "on_subscription"
        }
    }

    // MARK: - Pending Invoice Item Interval

    public struct PendingInvoiceItemInterval: Codable {
        /// Specifies invoicing frequency.
        public let interval: Interval
        /// The number of intervals between invoices.
        public let intervalCount: Int

        public init(interval: Interval, intervalCount: Int) {
            self.interval = interval
            self.intervalCount = intervalCount
        }

        public enum CodingKeys: String, CodingKey {
            case interval,
                 intervalCount = "interval_count"
        }

        public enum Interval: String, Codable {
            case day
            case month
            case week
            case year
        }
    }

    // MARK: - Pending Update

    public struct PendingUpdate: Codable {
        /// If the update is applied, determines the date of the first full invoice.
        public let billingCycleAnchor: TimeInterval?
        /// The point after which the changes reflected will be discarded.
        public let expiresAt: TimeInterval
        /// The point after which the subscription would have a trial.
        public let trialEnd: TimeInterval?
        /// Indicates if a plan's trial_period_days should be applied.
        public let trialFromPlan: Bool?

        public init(billingCycleAnchor: TimeInterval?, expiresAt: TimeInterval, trialEnd: TimeInterval?, trialFromPlan: Bool?) {
            self.billingCycleAnchor = billingCycleAnchor
            self.expiresAt = expiresAt
            self.trialEnd = trialEnd
            self.trialFromPlan = trialFromPlan
        }

        public enum CodingKeys: String, CodingKey {
            case billingCycleAnchor = "billing_cycle_anchor",
                 expiresAt = "expires_at",
                 trialEnd = "trial_end",
                 trialFromPlan = "trial_from_plan"
        }
    }

    // MARK: - Transfer Data

    public struct TransferData: Codable {
        /// A non-negative decimal between 0 and 100.
        public let amountPercent: Double?
        /// The account where funds from the payment will be transferred to.
        public let destination: String

        public init(amountPercent: Double?, destination: String) {
            self.amountPercent = amountPercent
            self.destination = destination
        }

        public enum CodingKeys: String, CodingKey {
            case amountPercent = "amount_percent",
                 destination
        }
    }

    // MARK: - Trial Settings

    public struct TrialSettings: Codable {
        /// Defines how the subscription should behave when the user's trial ends.
        public let endBehavior: EndBehavior

        public init(endBehavior: EndBehavior) {
            self.endBehavior = endBehavior
        }

        public enum CodingKeys: String, CodingKey {
            case endBehavior = "end_behavior"
        }

        public struct EndBehavior: Codable {
            /// Indicates how the subscription should change when the trial ends.
            public let missingPaymentMethod: MissingPaymentMethod

            public init(missingPaymentMethod: MissingPaymentMethod) {
                self.missingPaymentMethod = missingPaymentMethod
            }

            public enum CodingKeys: String, CodingKey {
                case missingPaymentMethod = "missing_payment_method"
            }

            public enum MissingPaymentMethod: String, Codable {
                case cancel
                case createInvoice = "create_invoice"
                case pause
            }
        }
    }
}

// MARK: - Subscription Item

public struct SubscriptionItem: Codable {
    /// Unique identifier for the object.
    public let id: String
    /// String representing the object's type.
    public let object: String
    /// Define thresholds at which an invoice will be sent.
    public let billingThresholds: ItemBillingThresholds?
    /// Time at which the object was created.
    public let created: TimeInterval
    /// The discounts applied to the subscription item.
    public let discounts: [String]
    /// Set of key-value pairs.
    public let metadata: Metadata
    /// The price the customer is subscribed to.
    public let price: Price
    /// The quantity of the plan to which the customer should be subscribed.
    public let quantity: Int?
    /// The subscription this subscription_item belongs to.
    public let subscription: String
    /// The tax rates which apply to this subscription_item.
    public let taxRates: [TaxRate]?

    public init(id: String, object: String, billingThresholds: ItemBillingThresholds?, created: TimeInterval, discounts: [String], metadata: Metadata, price: Price, quantity: Int?, subscription: String, taxRates: [TaxRate]?) {
        self.id = id
        self.object = object
        self.billingThresholds = billingThresholds
        self.created = created
        self.discounts = discounts
        self.metadata = metadata
        self.price = price
        self.quantity = quantity
        self.subscription = subscription
        self.taxRates = taxRates
    }

    public enum CodingKeys: String, CodingKey {
        case id,
             object,
             billingThresholds = "billing_thresholds",
             created,
             discounts,
             metadata,
             price,
             quantity,
             subscription,
             taxRates = "tax_rates"
    }

    public struct ItemBillingThresholds: Codable {
        /// Usage threshold that triggers the subscription to create an invoice.
        public let usageGte: Int?

        public init(usageGte: Int?) {
            self.usageGte = usageGte
        }

        public enum CodingKeys: String, CodingKey {
            case usageGte = "usage_gte"
        }
    }
}

// MARK: - Tax Rate

public struct TaxRate: Codable {
    /// Unique identifier for the object.
    public let id: String
    /// String representing the object's type.
    public let object: String
    /// Whether the tax rate is currently available for use.
    public let active: Bool
    /// Two-letter country code.
    public let country: String?
    /// Time at which the object was created.
    public let created: TimeInterval
    /// An arbitrary string attached to the tax rate for your internal use.
    public let taxRateDescription: String?
    /// The display name of the tax rate.
    public let displayName: String
    /// Actual/effective tax rate percentage.
    public let effectivePercentage: Double?
    /// This specifies if the tax rate is inclusive or exclusive.
    public let inclusive: Bool
    /// The jurisdiction for the tax rate.
    public let jurisdiction: String?
    /// The level of the jurisdiction that imposes this tax.
    public let jurisdictionLevel: String?
    /// Has the value `true` if the object exists in live mode.
    public let livemode: Bool
    /// Set of key-value pairs.
    public let metadata: Metadata?
    /// Tax rate percentage.
    public let percentage: Double
    /// Indicates the type of tax rate.
    public let rateType: String?
    /// ISO 3166-2 subdivision code.
    public let state: String?
    /// The high-level tax type.
    public let taxType: String?

    public init(id: String, object: String, active: Bool, country: String?, created: TimeInterval, taxRateDescription: String?, displayName: String, effectivePercentage: Double?, inclusive: Bool, jurisdiction: String?, jurisdictionLevel: String?, livemode: Bool, metadata: Metadata?, percentage: Double, rateType: String?, state: String?, taxType: String?) {
        self.id = id
        self.object = object
        self.active = active
        self.country = country
        self.created = created
        self.taxRateDescription = taxRateDescription
        self.displayName = displayName
        self.effectivePercentage = effectivePercentage
        self.inclusive = inclusive
        self.jurisdiction = jurisdiction
        self.jurisdictionLevel = jurisdictionLevel
        self.livemode = livemode
        self.metadata = metadata
        self.percentage = percentage
        self.rateType = rateType
        self.state = state
        self.taxType = taxType
    }

    public enum CodingKeys: String, CodingKey {
        case id,
             object,
             active,
             country,
             created,
             taxRateDescription = "description",
             displayName = "display_name",
             effectivePercentage = "effective_percentage",
             inclusive,
             jurisdiction,
             jurisdictionLevel = "jurisdiction_level",
             livemode,
             metadata,
             percentage,
             rateType = "rate_type",
             state,
             taxType = "tax_type"
    }
}
